<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>kmcconnaughay.github.io</title>
  <meta name="viewport" content="width=device-width">
  <link rel="stylesheet" type="text/css" href="article.css">
  <link rel="stylesheet" type="text/css" href="background.css">
  <link rel="stylesheet" type="text/css" href="body.css">
  <link rel="stylesheet" type="text/css" href="img.css">
  <link rel="stylesheet" type="text/css" href="nav.css">
</head>
<body class="dark-gray-background">
  <nav class="gray-background">
    <a href="https://kmcconnaughay.github.io"><img id="logo" class="small-square-icon" src="images/logo.svg" alt=
    "Site logo"></a> <a class="medium-text white-text" href=
    "https://www.github.com/kmcconnaughay/kmcconnaughay.github.io">GitHub</a>
  </nav>
  <article class="gray-background teal-border card" id="decompressing-strings-interview-edition">
    <header>
      <h1 class="large-text white-text title-text">Decompressing Strings, Interview Edition</h1>
      <h2 class="small-text white-text date-text"><time datetime="2020-03-31">2020-03-31</time></h2>
    </header>
    <section class="medium-text white-text content-text">
      <p>My worst interview experience happened at $CURRENT_EMPLOYER in early <time datetime="2016">2016</time>. It was
      not the fault of my interviewer. She had been hastily summoned to my room after my original interviewer canceled
      and, not ten minutes after she arrived, another rather persistent woman claimed the room for a Very Important™
      meeting with Key Clients™.</p>
      <p>Thus began a long trek through the building as we desperately sought an unoccupied room with a whiteboard.
      This being $CURRENT_EMPLOYER on a weekday in the middle of the afternoon, such spots were a coveted and rare
      commodity. My interviewer made the occassional foray into small talk as we quested, but I intuited that she felt
      as panicked as me and our abortive attempts at conversation eventually ceased.</p>
      <p>And lo, twenty minutes later and a mere ten minutes before the end of my interview we found a suitable space.
      I rushed to the whiteboard to recreate my first ten minutes of work while also trying to remember what exactly my
      interviewer had asked me to solve and wondering whether the lost time would negatively affect my hiring decision
      and for <i>science's</i> sake what did she ask me to do...</p>
      <p>I did not write anything close to a working solution in that interview, but the <i>uniqueness</i> of the
      experience left the problem indelibly imprinted in my psyche. Now, as I self-isolate in the midst of a global
      pandemic, I am bored to death and looking for things to do, so I finally solved it. Take that, imposter
      syndrome.</p>
      <p>The problem is to decompress strings. Given the string "a2(xy)b", write a <code class=
      "inline-code">decompress</code> function that returns "axyxyb", i.e. duplicate the parts inside parentheses a
      number of times indicated by the leading number.</p>
      <p>Some necessary clarifications:</p>
      <ul>
        <li>Multiple parenthetical blocks are allowed, e.g. "2(x)3(y)" should expand to "xxyyy".</li>
        <li>Nested parenthetical blocks are allowed, e.g. "2(x3(y))" should expand to "xyyyxyyy".</li>
        <li>If the input is malformed, e.g. a closing parenthesis is missing, the function should throw an
        exception.</li>
      </ul>
      <p>This is a parsing problem! And as such the first step is to define the relevant <a href=
      "https://en.wikipedia.org/wiki/Context-free_grammar">grammar</a>. A <code class=
      "inline-code">&lt;letter&gt;</code> is a terminal symbol:</p>
      <pre><code class="code-block">&lt;letter&gt; ::= [A-Za-z]</code></pre>
      <p>The above is given in <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">Backus-Naur Form</a>
      augmented with <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a>. It means that
      the <code class="inline-code">&lt;letter&gt;</code> symbol can be exactly one of "A", "B", "C", ..., "X", "Y",
      "Z", "a", "b", "c", ..., "x", "y", or "z".</p>
      <p>A <code class="inline-code">&lt;digit&gt;</code> is also a terminal symbol:</p>
      <pre><code class="code-block">&lt;digit&gt; ::= [0-9]</code></pre>
      <p>This means that a <code class="inline-code">&lt;digit&gt;</code> can be exactly one of 0, 1, 2, 3, 4, 5, 6, 7,
      8, or 9.</p>
      <p>To represent numbers that have more than one digit, we need to introduce our first recursive (as opposed to
      terminal) symbol, <code class="inline-code">&lt;number&gt;</code>:</p>
      <pre><code class="code-block">&lt;number&gt; :: = &lt;digit&gt;&lt;number&gt; | &lt;digit&gt;</code></pre>
      <p class="narrow-screen-only">(If your browser window is too narrow to see the full definition, e.g. you're using
      a mobile phone, you can scroll the orange boxes horizontally.)</p>
      <p>We can use this to understand numbers with more than one digit. Here's how we might use the definition to
      parse 735:</p>
      <ol>
        <li>Use the left definition, <code class="inline-code">&lt;digit&gt;&lt;number&gt;</code>. 7 matches the
        definition of <code class="inline-code">&lt;digit&gt;</code> and we try to parse 35 according to the definition
        of <code class="inline-code">&lt;number&gt;</code>.</li>
        <li>Use the left definition again. 3 matches the definition of <code class="inline-code">&lt;digit&gt;</code>
        and we try to parse 5 according to the definition of <code class="inline-code">&lt;number&gt;</code>.</li>
        <li>Now we only have 5. The left definition no longer applies because there are no digits that follow 5, so we
        apply the right definition. 5 matches the definition of <code class="inline-code">&lt;digit&gt;</code> and we
        are finished parsing. 735 is three digits.</li>
      </ol>
      <p>The next two rules are more complicated, but they are mutually recursive and so must be introduced
      together.</p>
      <pre><code class=
      "code-block">&lt;compression&gt; ::= &lt;letter&gt;&lt;compression&gt; | &lt;block&gt;&lt;compression&gt; | ""
&lt;block&gt; ::= &lt;number&gt;"("&lt;compression&gt;")"</code></pre>
      <p>Though more complicated than the definition of <code class="inline-code">&lt;number&gt;</code>, these follow
      the same basic principles. A <code class="inline-code">&lt;compression&gt;</code> can be a <code class=
      "inline-code">&lt;letter&gt;</code> followed by another compressed string, a <code class=
      "inline-code">&lt;block&gt;</code> followed by another compressed string, or the empty string. A <code class=
      "inline-code">&lt;block&gt;</code> is a <code class="inline-code">&lt;number&gt;</code> followed by an open
      parenthesis, then a compressed string (which we just defined), and finally a close parenthesis.</p>
      <p>Here is the full grammar:</p>
      <pre><code class=
      "code-block">&lt;compression&gt; ::= &lt;letter&gt;&lt;compression&gt; | &lt;block&gt;&lt;compression&gt; | ""
&lt;letter&gt; ::= [A-Za-z]
&lt;block&gt; ::= &lt;number&gt;"("&lt;compression&gt;")"
&lt;number&gt; ::= &lt;digit&gt;&lt;number&gt; | &lt;digit&gt;
&lt;digit&gt; ::= [0-9]</code></pre>
      <p>Try parsing the following strings from the definition of <code class=
      "inline-code">&lt;compression&gt;</code>!</p>
      <ol>
        <li>"a"</li>
        <li>"ab"</li>
        <li>"13(x)"</li>
        <li>"2(x)3(y)"</li>
        <li>"2(m3(n))"</li>
        <li>"ab4(x5(y)z)2(mn)"</li>
      </ol>
      <p>Let's walk through the last example in detail. Each line is the result of applying one definition to the
      string and we already know that we start with a <code class="inline-code">&lt;compression&gt;</code></p>
      <ul>
        <li>"ab4(x5(y)z)2(mn)" is a <code class="inline-code">&lt;compression&gt;</code></li>
        <li>"a" is a <code class="inline-code">&lt;letter&gt;</code> and "b4(x5(y)z)2(mn)" is a <code class=
        "inline-code">&lt;compression&gt;</code></li>
        <li>"b" is a <code class="inline-code">&lt;letter&gt;</code> and "4(x5(y)z)2(mn)" is a <code class=
        "inline-code">&lt;compression&gt;</code></li>
        <li>"4(x5(y)z)" is a <code class="inline-code">&lt;block&gt;</code> and "2(mn)" is a <code class=
        "inline-code">&lt;compression&gt;</code></li>
        <li>"2(mn)" is a <code class="inline-code">&lt;block&gt;</code></li>
      </ul>
      <p>We can continue to break down the string "4(x5(y)z)" that we found:</p>
      <ul>
        <li>"4(x5(y)z)" is a <code class="inline-code">&lt;block&gt;</code></li>
        <li>"4" is a <code class="inline-code">&lt;number&gt;</code>, "(" is an open parenthesis, "x5(y)z" is a
        <code class="inline-code">&lt;compression&gt;</code>, and ")" is a close parenthesis</li>
      </ul>
      <p>And we could continue to break down the string "x5(y)z" we found in the last step, but I'll leave that as an
      exercise to the (inhumanly) diligent reader.</p>
      <p>Of course, just understanding the structure of a given string isn't enough. We also need to evaluate it to get
      the final decompressed string. In the examples above, this is what we'd like the output of our <code class=
      "inline-code">decompress</code> function to be:</p>
      <ol>
        <li>"a"</li>
        <li>"ab"</li>
        <li>"xxxxxxxxxxxxx"</li>
        <li>"xxyyy"</li>
        <li>"mnnnmnnn"</li>
        <li>"abxyyyyyzxyyyyyzxyyyyyzxyyyyyzmnmn"</li>
      </ol>
      <p>We are finally at the point where we can start writing code. For the sake of my personal erudition I decided
      to use a neat little Python library called <a href="https://pythonhosted.org/parsec/">Parsec</a>. It provides a
      selection of <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinators</a> that ease the
      development of bespoke parsers.</p>
      <p>Let's again start simply. How do we parse a letter?</p>
      <pre><code class="code-block">import parsec
parsec.letter().parse("a") # returns "a"
parsec.letter().parse("1") # throws an exception</code></pre>
      <p>Neat. And a digit?</p>
      <pre><code class="code-block">parsec.digit().parse("1") # returns "1"
parsec.digit().parse(")") # throws an exception</code></pre>
      <p>Okay, those are easy. What about parsing a number, which can have many digits?</p>
      <pre><code class="code-block">parsec.many1(parsec.digit()).parse("123") # returns ["1", "2", "3"]
parsec.many1(parsec.digit()).parse("3a4") # throws an exception</code></pre>
      <p>The <code class="inline-code">parsec.many1</code> function accepts a parser as an argument and returns another
      parser that uses the argument one to many times. However, the output isn't quite what we want. We don't want a
      list of strings of digits, we want a real integer. We can write an <code class=
      "inline-code">_evaluate_number</code> function to do this:</p>
      <pre><code class="code-block">from typing import *

def _evaluate_number(parsed_number: List[str]) -&gt; int:
    return int("".join(parsed_number))</code></pre>
      <p>Given a list of strings, the <code class="inline-code">_evaluate_number</code> function concatenates them and
      casts the result to an integer. Let's combine our parser and evaluator:</p>
      <pre><code class="code-block">def _number() -&gt; parsec.Parser():
    return parsec.many1(parsec.digit()).parsecmap(_evaluate_number)

_number().parse("543") # returns 543</code></pre>
      <p>To simplify things, let's assume that we have a function that provides a <code class=
      "inline-code">&lt;block&gt;</code> parser:</p>
      <pre><code class="code-block">def _block() -&gt; parsec.Parser:
    # We'll implement this soon
    pass</code></pre>
      <p>Let's use it to write a <code class="inline-code">&lt;compression&gt;</code> parser:</p>
      <pre><code class="code-block">def _compression() -&gt; parsec.Parser:
    return parsec.many(parsec.letter() ^ _block())</code></pre>
      <p>The <code class="inline-code">^</code> operator takes two parsers and returns a new parser that, when given
      input, tries the parser on the left and, if that fails, tries the parser on the right. The <code class=
      "inline-code">parsec.many</code> function is almost identical to the <code class=
      "inline-code">parsec.many1</code> function, except that <code class="inline-code">parsec.many1</code> must use
      its parser at least once while <code class="inline-code">parsec.many</code> can use its parser zero times. So, in
      literate English, the <code class="inline-code">_compression</code> function returns a parser that matches either
      a letter or a block zero or more times.</p>
      <p>Now we can return to the definition of the block parser. Let's try the obvious definition:</p>
      <pre><code class="code-block">def _block() -&gt; parsec.Parser:
    return _number() + (
        parsec.string("(") &gt;&gt; _compression() &lt;&lt; parsec.string(")")
    )</code></pre>
      <p>There's a lot going on here, so let's examine each part. The <code class="inline-code">+</code> operator
      combines two parsers. First it runs the parser on the left side of the operator, then it runs the parser on the
      right side of the operator, and last it returns the results of both parsers. The <code class=
      "inline-code">&gt;&gt;</code> operator takes two parsers and discards the result of the parser on the left side
      of the operator. Similarly, the <code class="inline-code">&lt;&lt;</code> operator takes two parsers and discards
      the result of the parser on the right side of the operator. So <code class="inline-code">parsec.string("(")
      &gt;&gt; _compression() &lt;&lt; parsec.string(")")</code> is a parser that matches an open parenthesis, a
      <code class="inline-code">&lt;compression&gt;</code>, and a close parenthesis but only retains the output of the
      <code class="inline-code">_compression</code> parser, discarding the parentheses. Thus the entire <code class=
      "inline-code">_block</code> function returns a parser that parses a <code class=
      "inline-code">&lt;number&gt;</code> and a <code class="inline-code">&lt;compression&gt;</code>.</p>
      <p>Unfortunately, the naive definition doesn't work because it recurses forever. Python is an <a href=
      "https://en.wikipedia.org/wiki/Eager_evaluation">eagerly evaluated</a> language, so when we invoke the
      <code class="inline-code">_compression</code> function, it calls the <code class="inline-code">_block</code>
      function which calls the <code class="inline-code">_compression</code> function which calls the <code class=
      "inline-code">_block</code> function which calls the <code class="inline-code">_compression</code>
      function...</p>
      <p>We can get around this by manually making Python lazy:</p>
      <pre><code class="code-block">def _block() -&gt; parsec.Parser:
    @parsec.Parser
    def parse(text, index) -&gt; Tuple[int, List[str]]:
        p = (
            _number() + (
                parsec.string("(") &gt;&gt; _compression() &lt;&lt; parsec.string(")")
            )
        )
        return p(text, index)

    return parse</code></pre>
      <p>Now the <code class="inline-code">_block</code> function returns another function (which the <code class=
      "inline-code">@parsec.Parser</code> annotation turns into a fully-fledged parser) that parses a <code class=
      "inline-code">&lt;block&gt;</code> but, crucially, does <i>not</i> invoke that function, meaning that
      <code class="inline-code">_compression</code> won't be called until it's needed.</p>
      <p>Now all that remains is to write accompanying evaluate functions:</p>
      <pre><code class="code-block">def _evaluate_block(parsed_block: Tuple[int, List[str]]) -&gt; str:
    num_repetitions, letters = parsed_block
    return "".join(num_repetitions * letters)

def _evaluate_compression(parsed_compression: List[str]) -&gt; str:
    return "".join(parsed_compression)</code></pre>
      <p>The <code class="inline-code">_evaluate_block</code> function takes a tuple whose first element is the output
      of the <code class="inline-code">_number</code> parser and whose second element is the output of the <code class=
      "inline-code">_compression</code> parser. It then repeats the output of the <code class=
      "inline-code">_compression</code> parser as many times as indicated by the <code class=
      "inline-code">_number</code> parser.</p>
      <p>The <code class="inline-code">_evaluate_compression</code> function takes a list of strings that are the
      outputs of many invocations of the <code class="inline-code">parsec.letter</code> parser and our <code class=
      "inline-code">_block</code> parser, concatenates the strings, and returns the result.</p>
      <p>We can plug the evaluate functions into our parsers with <code class="inline-code">parsecmap</code>:</p>
      <pre><code class="code-block">def _block() -&gt; parsec.Parser:
    @parsec.Parser
    def parse(text, index) -&gt; str:
        p = (
            _number() + (
                parsec.string("(") &gt;&gt; _compression() &lt;&lt; parsec.string(")")
            )
        ).parsecmap(_evaluate_block)
        return p(text, index)

    return parse

def _compression() -&gt; parsec.Parser:
    return parsec.many(
        parsec.letter() ^ _block()
    ).parsecmap(_evaluate_compression)</code></pre>
      <p>Et voilà, we have a fully fledged parser! We can write a <code class="inline-code">decompress</code> function
      which satisfies the definition given in the original problem:</p>
      <pre><code class="code-block">def decompress(text: str) -&gt; str:
    return _compression().parse_strict(text)

decompress("abc") # returns "abc"
decompress("2(xy)") # returns "xyxy"
decompress("a2(x3(y)z)b") # returns "axyyyzxyyyzb"</code></pre>
      <p>Here is the full code:</p>
      <pre><code class="code-block">def decompress(text: str) -&gt; str:
    return _compression().parse_strict(text)

def _compression() -&gt; parsec.Parser:
    return parsec.many(
        parsec.letter() ^ _block()
    ).parsecmap(_evaluate_compression)

def _evaluate_compression(parsed_compression: List[str]) -&gt; str:
    return "".join(parsed_compression)

def _block() -&gt; parsec.Parser:
    @parsec.Parser
    def parse(text, index) -&gt; str:
        p = (
            _number() + (
                parsec.string("(") &gt;&gt; _compression() &lt;&lt; parsec.string(")")
            )
        ).parsecmap(_evaluate_block)
        return p(text, index)

    return parse

def _evaluate_block(parsed_block: Tuple[int, List[str]]) -&gt; str:
    num_repetitions, letters = parsed_block
    return "".join(num_repetitions * letters)

def _number() -&gt; parsec.Parser:
    return parsec.many1(parsec.digit()).parsecmap(_evaluate_number)

def _evaluate_number(parsed_number: List[str]) -&gt; int:
    return int("".join(parsed_number))</code></pre>
      <p>Note that you should <i>definitely</i> not use this code in any kind of production system; there are better
      ways to compress data and this code is vulnerable to things like the <a href=
      "https://en.wikipedia.org/wiki/Billion_laughs_attack">billion laughs attack</a>. But it was fun to learn more
      about parsers and to slay some of my closeted dragons.</p>
      <p>Until next time, adieu.</p>
    </section>
  </article>
  <article class="gray-background teal-border card" id="learning-mathml">
    <header>
      <h1 class="large-text white-text title-text">Learning MathML</h1>
      <h2 class="small-text white-text date-text"><time datetime="2019-11-17">2019-11-17</time></h2>
    </header>
    <section class="medium-text white-text content-text">
      <p>Going forward, I expect that math will be a subject I discuss on this blog. Before discussing it, though, I
      needed to learn how to display math formulas in the browser. Based on my research, there are a few approaches one
      can take:</p>
      <ol>
        <li>Render your formluas in TeX (or similar) and display them as images.</li>
        <li>Use a JavaScript library like <a href="https://www.mathjax.org/">MathJax</a> to render TeX equations (or
        similar) as SVG images, HTML+CSS, and/or <a href="https://en.wikipedia.org/wiki/MathML">MathML</a>, an
        ISO-standard XML schema for math equations, in the client's browser.
        </li>
        <li>Do something dumb like hand-write your equations in MathML, breaking your website's cross-browser
        compatibility in the process because, despite the fact that the HTML5 standard has included MathML <a href=
        "https://en.wikipedia.org/wiki/MathML">since <time datetime="2015">2015</time></a>, Chrome and its variants
        (Edge, Safari, Brave, etc.) still do not support it.
        </li>
      </ol>
      <p>Naturally I settled on the third option because, before today, I had never heard of MathML and I was curious.
      To learn the basics, I decided to transcribe the <a href=
      "https://en.wikipedia.org/wiki/Cauchy%E2%80%93Schwarz_inequality">Cauchy-Schwarz Inequality</a> because it
      appears in the first few pages of my copy of <i><a href=
      "https://www.goodreads.com/book/show/292079.Principles_of_Mathematical_Analysis">Principles of Mathematical
      Analysis</a></i> and I lacked the motivation to look any further.</p>
      <p>Note that, as of <time datetime="2019-11-17">November 17th, 2019</time>, Firefox is the only browser <a href=
      "https://developer.mozilla.org/en-US/docs/Web/MathML/Element/math#Browser_compatibility">that fully supports
      MathML</a>. If your browser does not correctly render what follows, <a href=
      "images/cauchy-schwarz-inequality.png">here</a> is an image of the equations as rendered by Firefox.</p>
      <p>Given <math>
      <mrow>
        <mrow>
          <msub>
            <mi>
              a
            </mi>
            <mn>
              1
            </mn>
          </msub>
          <mo>
            &hellip;
          </mo>
          <msub>
            <mi>
              a
            </mi>
            <mi>
              n
            </mi>
          </msub>
        </mrow>
        <mo>
          &isin;
        </mo>
        <mi>
          &#x2102;<!--DOUBLE-STRUCK CAPITAL C-->
        </mi>
      </mrow></math> and <math>
      <mrow>
        <mrow>
          <msub>
            <mi>
              b
            </mi>
            <mn>
              1
            </mn>
          </msub>
          <mo>
            &hellip;
          </mo>
          <msub>
            <mi>
              b
            </mi>
            <mi>
              n
            </mi>
          </msub>
        </mrow>
        <mo>
          &isin;
        </mo>
        <mi>
          &#x2102;<!--DOUBLE-STRUCK CAPITAL C-->
        </mi>
      </mrow></math>, where <math>
      <mover>
        <mi>
          z
        </mi>
        <mo>
          &oline;
        </mo>
      </mover></math> is the complex conjugate of <math>
      <mrow>
        <mi>
          z
        </mi>
        <mo>
          &isin;
        </mo>
        <mi>
          &#x2102;<!--DOUBLE-STRUCK CAPITAL C-->
        </mi>
      </mrow></math> and <math>
      <mrow>
        <mrow>
          <mo>
            |
          </mo>
          <mi>
            z
          </mi>
          <mo>
            |
          </mo>
        </mrow>
        <mo>
          =
        </mo>
        <msup>
          <mrow>
            <mo>
              (
            </mo>
            <mi>
              z
            </mi>
            <mo>
              &#x2062;<!--INVISIBLE TIMES-->
            </mo>
            <mover>
              <mi>
                z
              </mi>
              <mo>
                &oline;
              </mo>
            </mover>
            <mo>
              )
            </mo>
          </mrow>
          <mfrac>
            <mn>
              1
            </mn>
            <mn>
              2
            </mn>
          </mfrac>
        </msup>
      </mrow></math> is the absolute value of <math>
      <mi>
        z
      </mi></math>, the Cauchy-Schwarz Inequality is the following:</p><math display="block" id=
      "cauchy-schwarz-inequality">
      <mrow>
        <msup>
          <mrow>
            <mrow>
              <mo>
                |
              </mo>
              <munderover>
                <mo>
                  &sum;
                </mo>
                <mrow>
                  <mi>
                    j
                  </mi>
                  <mo>
                    =
                  </mo>
                  <mn>
                    1
                  </mn>
                </mrow>
                <mi>
                  n
                </mi>
              </munderover>
              <mrow>
                <msub>
                  <mi>
                    a
                  </mi>
                  <mi>
                    j
                  </mi>
                </msub>
                <mo>
                  &#x2062;<!--INVISIBLE TIMES-->
                </mo>
                <msub>
                  <mover>
                    <mi>
                      b
                    </mi>
                    <mo>
                      &oline;
                    </mo>
                  </mover>
                  <mi>
                    j
                  </mi>
                </msub>
              </mrow>
              <mo>
                |
              </mo>
            </mrow>
          </mrow>
          <mn>
            2
          </mn>
        </msup>
        <mo>
          &le;
        </mo>
        <mrow>
          <mrow>
            <munderover>
              <mo>
                &sum;
              </mo>
              <mrow>
                <mi>
                  j
                </mi>
                <mo>
                  =
                </mo>
                <mn>
                  1
                </mn>
              </mrow>
              <mi>
                n
              </mi>
            </munderover>
            <msup>
              <mrow>
                <mo>
                  |
                </mo>
                <msub>
                  <mi>
                    a
                  </mi>
                  <mi>
                    j
                  </mi>
                </msub>
                <mo>
                  |
                </mo>
              </mrow>
              <mn>
                2
              </mn>
            </msup>
          </mrow>
          <mo>
            &#x2062;<!--INVISIBLE TIMES-->
          </mo>
          <mrow>
            <munderover>
              <mo>
                &sum;
              </mo>
              <mrow>
                <mi>
                  j
                </mi>
                <mo>
                  =
                </mo>
                <mn>
                  1
                </mn>
              </mrow>
              <mi>
                n
              </mi>
            </munderover>
            <msup>
              <mrow>
                <mo>
                  |
                </mo>
                <msub>
                  <mi>
                    b
                  </mi>
                  <mi>
                    j
                  </mi>
                </msub>
                <mo>
                  |
                </mo>
              </mrow>
              <mn>
                2
              </mn>
            </msup>
          </mrow>
        </mrow>
      </mrow></math>
      <p>If you'd like to see the many lines of markup that produced this equation, search for the string
      "cauchy-schwarz-inequality" in the page source, which you can view in the browser or on <a href=
      "https://www.github.com/kmcconnaughay/kmcconnaughay.github.io">GitHub</a>.</p>
      <p>Here are some takeaways from this exercise:</p>
      <ol>
        <li>
          <a href=
          "https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML">
          HTML named entities</a> allow you to insert otherwise difficult-to-type symbols into your markup. For
          example, "∑", the capital Greek letter sigma oft used in summations, is written <code class=
          "inline-code">&amp;sum;</code> in HTML.
        </li>
        <li>For Unicode symbols that lack a named HTML entity, you can use their Unicode encoding directly. For
        example, "ℂ <!--DOUBLE-STRUCK CAPITAL C-->", the symbol commonly used to represent the set of complex numbers,
        is written <code class="inline-code">&amp;#x2102;</code> in HTML.</li>
        <li>MathML is verbose, but powerful. It comes with its own set of dedicated XML tags, like <code class=
        "inline-code">&lt;mfrac&gt;</code> for fractions and <code class="inline-code">&lt;msup&gt;</code> for
        superscript, that allow you to construct arbitrarily complex equations. I appreciate that Firefox does this in
        vanilla HTML without the need for heavy JavaScript polyfills.</li>
        <li>Because MathML is verbose, writing it by hand is error-prone. I did my best write it semantically, but it's
        <s>possible</s> probable that I missed an <code class="inline-code">&lt;mrow&gt;</code> tag or made other, less
        obvious errors. In the future I might use a TeX to MathML converter to generate the markup, instead.</li>
        <li>I need to find a good HTML formatter and a static page templater to make writing new posts easier. I'm not
        going to use a managed solution like WordPress because half the point of this website is to learn new things
        from first principles, but I think some minimal tooling will make my life easier.</li>
      </ol>
    </section>
  </article>
  <article class="gray-background teal-border card" id="statement-of-purpose">
    <header>
      <h1 class="large-text white-text title-text">Statement of Purpose</h1>
      <h2 class="small-text white-text date-text"><time datetime="2019-11-03">2019-11-03</time></h2>
    </header>
    <section class="medium-text white-text content-text">
      <p>Before making this website, I felt obliged to consider its utility. There are millions of blogs dedicated to
      sundry subjects; many of them are written by subject matter experts who know more about their respective fields
      than I could ever hope to learn. Further, even if I did have unique knowledge to offer others, I have no desire
      to market my blog. It thus seems unlikely that more than a few dozen people will ever read it, and I imagine that
      most of them will be family and close friends.</p>
      <p>Perhaps this explains my prior reluctance to make a personal website. My time is finite and to spend it on
      this endeavor seemed wasteful.</p>
      <p>And yet.</p>
      <p>Now, years after I first considered making a personal website, I think my hesitance rested on a faulty
      assumption. To measure the utility of a personal website solely by the value it delivers to others is
      short-sighted. Instead, I can view it as an investment into myself. There are the obvious learning opportunities
      - I am a professional software engineer, but I work exclusively on backend systems at my job, so this site offers
      a rare opportunity to try developing for the web. There are the obvious career considerations - a personal
      website is an engineering artifact that I can present to others as proof of competence, and I can also host a
      literal resume on it.</p>
      <p>But to me, this site's <i>raison d'être</i> is to serve as a chronicle of the things I do, learn, and see. I
      cannot remember everything, or even most things, and to consciously preserve the things I deem important for my
      future self seems a worthwhile goal.</p>
      <p>With this site I will go where many have gone before. But that's okay. This is for me.</p>
    </section>
  </article>
  <article class="gray-background teal-border card" id="under-construction">
    <header>
      <h1 class="large-text white-text title-text">Under Construction</h1>
      <h2 class="small-text white-text date-text"><time datetime="2019-10-27">2019-10-27</time></h2>
    </header><img class="teal-background large-square-icon" id="wrench" src="images/wrench.svg" alt="Wrench icon">
  </article>
</body>
</html>
